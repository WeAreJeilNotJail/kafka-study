# Chapter 3
## 카프카 기본 개념 설명

### 3-1. 카프카 브로커, 클러스터, 주키퍼

주키퍼는 클라이언트와 메시지를 주고 받는 주체이다.

서버 한대로도 기능 실행되지만, 죽는 경우를 대비해 3대 이상을 띄우고 하나의 클러스터로 묶는다.

이들은 데이터를 분산 저장하고 복제하는 역할을 한다.

- __```데이터 저장, 전송```__

브로커는 프로듀서가 요청한 토픽의 파티션에 데이터 저장하고 컨슈머가 요청하면 해당 데이터를 전달하고 
프로듀서로부터 받은 데이터는 파일 시스템에 저장된다.

```
{topic}-{topic}의 이름으로 저장 (ex. hello.kafka-0)
.index .log .timeindex 등 존재
- log: 메타 데이터
- index: 메시지의 오프셋 인덱싱한 정보
- timeindex: 메시지에 포함된 timestamp 값을 기준으로 인덱싱한 정보 
```

카프카는 메모리, db를 이용하지 않고 파일 시스템에 저장하지만 ```페이지 캐시```를 사용하여 디스크 입출력 속도를 높인다.

*페이지 캐시*

OS에서 파일 입출력의 성능 향상을 위해 만든 메모리 영역으로 추후 동일한 파일 접근이 있을 때,
파일에서 읽지 않고 메모리에서 읽는다.

- __```데이터 복제, 싱크```__

클러스터 내의 브로커 중 일부가 죽어도 나머지가 동작해 데이터를 유실하지 않고 안전하게 사용 가능하다.

데이터 복제는 파티션 단위로 이루어진다. (파티션은 리더 + 팔로워로 구성)

```
리더: 프로듀서, 컨슈머와 직접 통신하는 파티션
팔로워: 나머지 복제 데이터를 갖는 파티션
```

팔로워는 리더의 오프셋을 확인해서 차이가 나면 데이터를 가져와 자신의 파티션에 저장하게 되는데 이를 "복제"라고 부른다.

- __```컨트롤러```__

클러스터의 브로커 중 한대가 컨트롤러의 역할을 하며, 다른 브로커들의 상태를 체크하고 클러스터에서 브로커가 빠지는 경우 리더 파티션을 재분배한다.

- __```데이터 삭제```__

컨슈머가 데이터를 가져가도 토픽의 데이터는 삭제되지 않는다. 오직 브로커만이 삭제할 수 있고, 파일 단위로 이루어진다. (로그 세그먼트)

데이터가 쌓이는 동안 파일 시스템으로 열려 있으며 1GB(기본값) 용량에 도달하면 닫히게 되고 log.retention.bytes, log.retention.ms 설정값을 넘으면 삭제된다.

- __```컨슈머 오프셋 저장```__

컨슈머 그룹은 어디까지 데이터를 읽었는지 알기 위해 오프셋을 커밋하고 저장한다.

- __```코디네이터```__

클러스터의 브로커 중 한대가 담당하며, 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배한다.

***

### 3-2. 토픽과 파티션

토픽은 데이터를 구분하는 단위이며 1개 이상의 파티션을 갖는다.

파티션에는 프로듀서가 보낸 데이터가 담기는데 이를 레코드라고 한다. (큐와 비슷)

컨슈머에서 데이터를 가져가도 사라지지 않기 때문에 여러 컨슈머 그룹들이 여러번 가져갈 수 있다.

***

### 3-3. 레코드

타임스탬프, 메시지 키, 메시지 값, 오프셋, 헤더로 구성된다.

동일한 메시지 키는 동일 파티션에 들어가게 된다. (파티션 갯수가 변경되면 메시지 키, 파티션 매칭이 달라짐)
-> 메시지 키를 설정하지 않으면 (null) 프로듀서 기본 설정 파티셔너에 따라 분배

메시지 키, 값은 직렬화해서 전달되기 때문에 동일한 형태로 컨슈머가 역직렬화 해야 한다.

헤더는 레코드의 추가 정보를 담는 메타데이터 저장소이다.

***

### 3-4. 카프카 클라이언트

__```프로듀서```__

프로듀서 애플리케이션은 데이터를 선언하고 브로커의 특정 파티션에 전송하는데 리더 파티션을 갖고 있는 브로커와 통신한다.

프로듀서는 데이터를 전송할 때, 파티셔너 -> 배치 생성 단계를 거친다.

- 파티셔너: 토픽의 어떤 파티션으로 전송할 것인지를 결정
- 배치: 파티셔너로 구분된 레코드들은 어큐뮬레이터에 버퍼로 쌓아놓고 배치로 한번에 전송 (처리량 향상)

__```컨슈머```__

컨슈머 그룹으로 묶인 컨슈머들은 토픽의 1개 이상 파티션에서 데이터를 가져갈 수 있다.

1개의 파티션은 최대 1개의 컨슈머에 할당되는데, 파티션의 갯수 < 컨슈머의 갯수가 되면 놀고 있는 컨슈머가 생긴다.

```
파티션의 갯수 >= 컨슈머의 갯수
```

컨슈머 그룹 중 일부에 장애가 발생하면 해당 컨슈머에 할당된 파티션은 다른 컨슈머에 할당되는데 이를 **리밸런싱**이라고 한다.

__```오프셋 커밋```__

컨슈머는 브로커로부터 읽은 데이터의 정보를 **커밋**을 통해 기록한다.

어떤 컨슈머 그룹이 특정 토픽의 파티션을 몇번째까지 가져갔는지 **브로커**의 내부 토픽에 기록
-> 해당 과정이 제대로 되지 않으면 데이터 중복이 발생할 가능성이 있음

- commitSync: 동기 오프셋 커밋

poll() 메서드로 받은 마지막 레코드의 오프셋을 기준으로 커밋한다. 동기 커밋의 경우 완료되기까지 기다려야 하므로 처리량이 적다.

- commitAsync: 비동기 오프셋 커밋

poll() 메서드로 받은 마지막 레코드의 오프셋을 기준으로 커밋하지만 커밋이 완료될때까지 응답을 기다리지 않아 처리량이 더 많다.

